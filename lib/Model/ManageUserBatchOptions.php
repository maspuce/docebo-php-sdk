<?php
/**
 * ManageUserBatchOptions
 *
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swaagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * 
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 2.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 *
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Model;

use \ArrayAccess;

/**
 * ManageUserBatchOptions Class Doc Comment
 *
 * @category    Class
 * @package     Swagger\Client
 * @author      Swagger Codegen team
 * @link        https://github.com/swagger-api/swagger-codegen
 */
class ManageUserBatchOptions implements ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      * @var string
      */
    protected static $swaggerModelName = 'ManageUserBatchOptions';

    /**
      * Array of property to type mappings. Used for (de)serialization
      * @var string[]
      */
    protected static $swaggerTypes = [
        'change_user_password' => 'bool',
        'auto_assign_branch_to_pu' => 'bool',
        'update_user_info' => 'bool',
        'destination_branch' => 'string',
        'ignore_password_change_for_existing_users' => 'bool',
        'branch_option' => 'string'
    ];

    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of attributes where the key is the local name, and the value is the original name
     * @var string[]
     */
    protected static $attributeMap = [
        'change_user_password' => 'change_user_password',
        'auto_assign_branch_to_pu' => 'auto_assign_branch_to_pu',
        'update_user_info' => 'update_user_info',
        'destination_branch' => 'destination_branch',
        'ignore_password_change_for_existing_users' => 'ignore_password_change_for_existing_users',
        'branch_option' => 'branch_option'
    ];


    /**
     * Array of attributes to setter functions (for deserialization of responses)
     * @var string[]
     */
    protected static $setters = [
        'change_user_password' => 'setChangeUserPassword',
        'auto_assign_branch_to_pu' => 'setAutoAssignBranchToPu',
        'update_user_info' => 'setUpdateUserInfo',
        'destination_branch' => 'setDestinationBranch',
        'ignore_password_change_for_existing_users' => 'setIgnorePasswordChangeForExistingUsers',
        'branch_option' => 'setBranchOption'
    ];


    /**
     * Array of attributes to getter functions (for serialization of requests)
     * @var string[]
     */
    protected static $getters = [
        'change_user_password' => 'getChangeUserPassword',
        'auto_assign_branch_to_pu' => 'getAutoAssignBranchToPu',
        'update_user_info' => 'getUpdateUserInfo',
        'destination_branch' => 'getDestinationBranch',
        'ignore_password_change_for_existing_users' => 'getIgnorePasswordChangeForExistingUsers',
        'branch_option' => 'getBranchOption'
    ];

    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    public static function setters()
    {
        return self::$setters;
    }

    public static function getters()
    {
        return self::$getters;
    }

    

    

    /**
     * Associative array for storing property values
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     * @param mixed[] $data Associated array of property values initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['change_user_password'] = isset($data['change_user_password']) ? $data['change_user_password'] : null;
        $this->container['auto_assign_branch_to_pu'] = isset($data['auto_assign_branch_to_pu']) ? $data['auto_assign_branch_to_pu'] : null;
        $this->container['update_user_info'] = isset($data['update_user_info']) ? $data['update_user_info'] : null;
        $this->container['destination_branch'] = isset($data['destination_branch']) ? $data['destination_branch'] : null;
        $this->container['ignore_password_change_for_existing_users'] = isset($data['ignore_password_change_for_existing_users']) ? $data['ignore_password_change_for_existing_users'] : null;
        $this->container['branch_option'] = isset($data['branch_option']) ? $data['branch_option'] : null;
    }

    /**
     * show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalid_properties = [];

        if ($this->container['change_user_password'] === null) {
            $invalid_properties[] = "'change_user_password' can't be null";
        }
        if ($this->container['auto_assign_branch_to_pu'] === null) {
            $invalid_properties[] = "'auto_assign_branch_to_pu' can't be null";
        }
        if ($this->container['update_user_info'] === null) {
            $invalid_properties[] = "'update_user_info' can't be null";
        }
        if ($this->container['destination_branch'] === null) {
            $invalid_properties[] = "'destination_branch' can't be null";
        }
        if ($this->container['ignore_password_change_for_existing_users'] === null) {
            $invalid_properties[] = "'ignore_password_change_for_existing_users' can't be null";
        }
        if ($this->container['branch_option'] === null) {
            $invalid_properties[] = "'branch_option' can't be null";
        }
        return $invalid_properties;
    }

    /**
     * validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {

        if ($this->container['change_user_password'] === null) {
            return false;
        }
        if ($this->container['auto_assign_branch_to_pu'] === null) {
            return false;
        }
        if ($this->container['update_user_info'] === null) {
            return false;
        }
        if ($this->container['destination_branch'] === null) {
            return false;
        }
        if ($this->container['ignore_password_change_for_existing_users'] === null) {
            return false;
        }
        if ($this->container['branch_option'] === null) {
            return false;
        }
        return true;
    }


    /**
     * Gets change_user_password
     * @return bool
     */
    public function getChangeUserPassword()
    {
        return $this->container['change_user_password'];
    }

    /**
     * Sets change_user_password
     * @param bool $change_user_password If set to true, all newly created users will need to update their password when first logging in
     * @return $this
     */
    public function setChangeUserPassword($change_user_password)
    {
        $this->container['change_user_password'] = $change_user_password;

        return $this;
    }

    /**
     * Gets auto_assign_branch_to_pu
     * @return bool
     */
    public function getAutoAssignBranchToPu()
    {
        return $this->container['auto_assign_branch_to_pu'];
    }

    /**
     * Sets auto_assign_branch_to_pu
     * @param bool $auto_assign_branch_to_pu If set to true, when creating a new poweruser, he'll be automatically assigned to the branch he's added to (reflects branch_name, branch_code, branch_name_path and branch_code_path settings)
     * @return $this
     */
    public function setAutoAssignBranchToPu($auto_assign_branch_to_pu)
    {
        $this->container['auto_assign_branch_to_pu'] = $auto_assign_branch_to_pu;

        return $this;
    }

    /**
     * Gets update_user_info
     * @return bool
     */
    public function getUpdateUserInfo()
    {
        return $this->container['update_user_info'];
    }

    /**
     * Sets update_user_info
     * @param bool $update_user_info If set to true, if a listed user already exists, his details will be updated, if set to false, an error will be logged for each existing user
     * @return $this
     */
    public function setUpdateUserInfo($update_user_info)
    {
        $this->container['update_user_info'] = $update_user_info;

        return $this;
    }

    /**
     * Gets destination_branch
     * @return string
     */
    public function getDestinationBranch()
    {
        return $this->container['destination_branch'];
    }

    /**
     * Sets destination_branch
     * @param string $destination_branch Refers to the internal ID for a branch used as a fallback when no other branch settings have been set
     * @return $this
     */
    public function setDestinationBranch($destination_branch)
    {
        $this->container['destination_branch'] = $destination_branch;

        return $this;
    }

    /**
     * Gets ignore_password_change_for_existing_users
     * @return bool
     */
    public function getIgnorePasswordChangeForExistingUsers()
    {
        return $this->container['ignore_password_change_for_existing_users'];
    }

    /**
     * Sets ignore_password_change_for_existing_users
     * @param bool $ignore_password_change_for_existing_users If set to true, all updated users will need to updates their password when logging in next time (only has any effect when update_existing_users is true as well
     * @return $this
     */
    public function setIgnorePasswordChangeForExistingUsers($ignore_password_change_for_existing_users)
    {
        $this->container['ignore_password_change_for_existing_users'] = $ignore_password_change_for_existing_users;

        return $this;
    }

    /**
     * Gets branch_option
     * @return string
     */
    public function getBranchOption()
    {
        return $this->container['branch_option'];
    }

    /**
     * Sets branch_option
     * @param string $branch_option Can be &quot;autocreate&quot; or &quot;existing&quot;. When &quot;existing&quot; is selected, an error will be thrown when not a unique branch can be identified. When &quot;autocreate&quot; is selected and &quot;branch_name_path&quot; and &quot;branch_code_path&quot; are used, a new branch will be created
     * @return $this
     */
    public function setBranchOption($branch_option)
    {
        $this->container['branch_option'] = $branch_option;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     * @param  integer $offset Offset
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     * @param  integer $offset Offset
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     * @param  integer $offset Offset
     * @param  mixed   $value  Value to be set
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     * @param  integer $offset Offset
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(\Swagger\Client\ObjectSerializer::sanitizeForSerialization($this), JSON_PRETTY_PRINT);
        }

        return json_encode(\Swagger\Client\ObjectSerializer::sanitizeForSerialization($this));
    }
}


